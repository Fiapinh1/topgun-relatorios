<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mesclar Talhões (KML ⇄ KML/Shapefile)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Edição -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.pm@latest/dist/leaflet.pm.css" />
  <script src="https://unpkg.com/leaflet.pm@latest/dist/leaflet.pm.min.js"></script>

  <!-- Geoprocessamento / Conversões -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.8.0/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>
  <!-- Raster GeoTIFF no Leaflet -->
  <script src="https://unpkg.com/geotiff/dist-browser/geotiff.min.js"></script>
  <script src="https://unpkg.com/georaster/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>

  <!-- Exportação -->
  <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- shp-write via CDN (fallback adicional no código) -->
  <script src="https://cdn.jsdelivr.net/npm/shp-write@0.4.4/dist/shpwrite.js"></script>

  <style>
    :root{
      --bg:#f9fbff;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --accent:#c62828;
      --accent-2:#168f4b;
      --border:#e2e8f0;
    }
    html, body { height: 100%; }
    body { margin: 0; font-family: "Manrope","Segoe UI",system-ui,-apple-system,sans-serif; background:
      radial-gradient(circle at 20% 20%,rgba(198,40,40,0.08),transparent 36%),
      radial-gradient(circle at 80% 0%,rgba(22,143,75,0.08),transparent 42%),
      linear-gradient(160deg,#fdf7f4 0%,#f2f7ff 55%,#fdf7f4 100%);
      color: var(--text);
    }
    .app { display: grid; grid-template-rows: auto 1fr; height: 100vh; }
    header { display: flex; flex-wrap: wrap; gap: .5rem; align-items: center; padding: .6rem .8rem; border-bottom: 1px solid var(--border); background: var(--card); position: sticky; top: 0; z-index: 5; box-shadow:0 10px 20px rgba(15,23,42,0.08); }
    header h1 { font-size: 1rem; margin: 0 .5rem 0 0; font-weight: 700; color:var(--accent); letter-spacing:.02em; }
    header .grow { flex: 1; }
    .btn { background: #fff; color: var(--text); border: 1px solid var(--border); padding: .48rem .75rem; border-radius: 10px; cursor: pointer; box-shadow:0 10px 20px rgba(15,23,42,0.08); display: inline-flex; align-items: center; justify-content: center; gap: .4rem; min-height: 38px; }
    .btn:hover { border-color: var(--accent); background: rgba(198,40,40,0.06); }
    .btn.primary { background: linear-gradient(135deg,var(--accent),#ef5350); border-color: transparent; color:#fff; box-shadow:0 12px 24px rgba(198,40,40,0.22); }
    .btn.primary:hover { filter:brightness(1.05); }
    .btn.ghost { background: #fff; border-color: #d7dfe8; color: var(--text); }
    .btn.ghost.danger { color: var(--accent); border-color: #f4caca; background: #fff5f5; }
    .icon-btn { width: 38px; height: 38px; padding: .35rem; border-radius: 12px; }
    .icon-btn svg { width: 16px; height: 16px; stroke: currentColor; stroke-width: 1.8; fill: none; }
    .icon-btn.active { background: rgba(198,40,40,0.12); border-color: var(--accent); color: var(--accent); }
    .leaflet-bar .icon-btn { border-radius: 10px; width: 34px; height: 34px; border: 1px solid #e4e7ec; box-shadow: 0 8px 24px rgba(15,23,42,0.16); padding: 0; }
    .leaflet-bar .icon-btn:hover { background:#f1f5f9; }
    .leaflet-bar .icon-btn svg { width: 16px; height: 16px; }
    .area-label { color:#0f172a; font-weight:700; font-size:.85rem; text-shadow:none; }
    .area-label .area-badge { background: #fff; color:#0f172a; border:1px solid rgba(15,23,42,0.1); border-radius:12px; padding:6px 12px; box-shadow:0 8px 18px rgba(15,23,42,0.2); display:inline-flex; align-items:center; gap:8px; }
    .area-label .area-unit { font-size:.82rem; font-weight:600; color:#475569; }
    .controls { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
    .controls label { font-size: .85rem; opacity: .9; }
    .controls input[type="number"] { width: 8rem; padding: .45rem .5rem; background: #fff; color: var(--text); border: 1px solid var(--border); border-radius: .5rem; min-height: 38px; }
    .layout { display: grid; grid-template-columns: 320px 1fr; height: 100%; gap:12px; min-height: 0; }
    @media (max-width: 900px){ header{flex-direction:column; align-items:flex-start;} .layout { grid-template-columns: 1fr; grid-template-rows: 40vh 1fr; } }
    aside { border: 1px solid var(--border); background: var(--card); border-radius:14px; box-shadow:0 14px 28px rgba(15,23,42,0.08); display:flex; flex-direction:column; overflow:hidden; height: 100%; }
    aside header { position: sticky; top: 0; background: var(--card); border-bottom:1px solid var(--border); z-index:2; }
    #map { height: 100%; width: 100%; }
    .list { padding: .75rem; display: grid; gap: .5rem; flex:1; overflow: auto; max-height: none; min-height: 0; }
    .item { display: flex; gap: .5rem; align-items: center; justify-content: space-between; background: #f8fafc; border: 1px solid var(--border); border-radius: .5rem; padding: .5rem .6rem; box-shadow: inset 0 1px 0 rgba(255,255,255,0.6); }
    .pill { display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:40px; padding:.3rem .65rem; font-size: .75rem; background: #44814f; border-radius: 999px; border: 1px solid #44814f; color: #f9fbff; box-shadow: inset 0 1px 0 rgba(255,255,255,0.08); }
    .pill .pill-num { font-size: .95rem; font-weight:700; line-height:1.1; }
    .pill .pill-label { font-size: .7rem; line-height:1; opacity: .92; }
    .help { font-size: .8rem; opacity: .9; padding: .4rem .75rem; color:var(--muted); }
    /* Botão flutuante dentro do mapa */
    #map { position: relative; }
    .floating-merge { position: absolute; right: 16px; top: 16px; z-index: 1200; display:flex; gap:.4rem; align-items:center; }
    .floating-merge .btn { border-radius: 14px; padding: .65rem .9rem; gap:.35rem; }
    #btnMerge { display: none; }
    /* Notificação central */
    .notify-center { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%) scale(.98);
      background: #fff; color: var(--text); border: 1px solid var(--border); border-radius: .6rem; padding: .7rem 1rem;
      box-shadow: 0 10px 30px rgba(15,23,42,.18); z-index: 9999; opacity: 0; transition: opacity .18s ease, transform .18s ease;
      pointer-events: none; font-size: .95rem; }
    .notify-center.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    .notify-center.success { border-color: var(--accent-2); }
    .notify-center.error { border-color: var(--accent); }
    /* ConfirmaÇõÇœo inline */
    .confirm-overlay { position: fixed; inset: 0; background: rgba(15,23,42,0.45); backdrop-filter: blur(2px); display: flex; align-items: center; justify-content: center; z-index: 10000; }
    .confirm-card { background: #fff; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 16px 40px rgba(15,23,42,0.22); padding: 1.1rem 1.2rem; width: min(440px, 92vw); }
    .confirm-card h3 { margin: 0 0 .35rem 0; font-size: 1rem; color: var(--text); }
    .confirm-card p { margin: 0 0 .9rem 0; color: var(--muted); font-size: .95rem; line-height: 1.45; }
    .confirm-actions { display: flex; justify-content: flex-end; gap: .6rem; }
    .confirm-actions button { min-width: 92px; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Mesclar Talhões</h1>
      <div class="controls">
        <input id="fileInput" type="file" accept=".kml" multiple />
        <button id="btnClear" class="btn ghost danger icon-btn" title="Limpar tudo" aria-label="Limpar tudo"></button> 
      </div>
      <div class="grow"></div>
      <div class="controls">
        <label for="tol">Tolerância (m):</label>
        <input id="tol" type="number" min="0" step="1" value="10" />
        <button id="btnMerge" class="btn primary icon-btn" title="Mesclar selecionados" aria-label="Mesclar selecionados"></button>
        <button id="btnEdit" class="btn icon-btn" title="Editar" aria-label="Editar"></button>
        <button id="btnSaveEdits" class="btn icon-btn" title="Salvar edições" aria-label="Salvar edições"></button>
        <button id="btnCancelEdits" class="btn ghost icon-btn" title="Cancelar edições" aria-label="Cancelar edições"></button>
        <button id="btnExportKML" class="btn icon-btn" title="Exportar KML" aria-label="Exportar KML"></button>
        <button id="btnExportSHP" class="btn icon-btn" title="Exportar Shapefile" aria-label="Exportar Shapefile"></button>
      </div>
    </header>
    <div class="layout">
      <aside>
        <header style="padding:.6rem .75rem; border-bottom:1px solid #2a2d34; display:flex; align-items:center; justify-content:space-between; gap:.5rem;">
          <div>
            <div style="font-weight:600; font-size:.95rem;"></div>
            <div class="muted" style="font-size:.9rem;font-weight:800;color:#44814f;">Camadas</div>
          </div>
          <div style="display:flex; gap:.4rem; align-items:center;">
            <div class="pill">
              <div class="pill-num" id="countSelected">0</div>
              <div class="pill-label">select</div>
            </div>
            <div class="pill">
              <div class="pill-num" id="haSelected">0.00</div>
              <div class="pill-label">ha</div>
            </div>
            <div class="pill">
              <div class="pill-num" id="totalHa">0.00</div>
              <div class="pill-label">total ha</div>
            </div>
          </div>
        </header>
        <div id="list" class="list"></div>
        <div class="footer" style="padding:.6rem .75rem; border-top:1px solid var(--border); background:var(--card); position: sticky; bottom: 0; z-index:2; display:flex; gap:.5rem; flex-wrap:wrap;">
          <button id="btnSelectAll" class="btn ghost">Selecionar todos</button>
          <button id="btnSelectNone" class="btn ghost">Limpar seleção</button>
        </div>
      </aside>
      <div id="map"></div>
    </div>
  </div>

  <script>
    // Estado
    let map;
    let nextId = 1;
    const allItems = new Map(); // id -> { id, layer, feature, name, fileName }
    const selectedIds = new Set();
    const resultLayers = [];
    const resultFeatures = [];
    const resultColors = [];
    const resultLabels = [];
    let lastResult = null; // FeatureCollection com todos os resultados
    let editActive = false;
    let fillMode = false;
    let fillControlBtn = null;
    const selectedResultIds = new Set(); // índices dos resultFeatures/layers
    let lastInputBaseName = 'talhoes';
    const undoStack = [];
    const redoStack = [];

    // Estilos
    const basePalette = ['#3b82f6','#10b981','#f59e0b','#a855f7','#14b8a6','#ef4444','#6366f1','#84cc16','#f97316','#0ea5e9','#d946ef','#06b6d4'];
    const baseStyle = { color: '#3b82f6', weight: 2, fillColor: '#3b82f6', fillOpacity: 0.3 };
    const selectedStyle = { color: '#22c55e', weight: 3, fillColor: '#22c55e', fillOpacity: 0.25 };
    const ICONS = {
      merge: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 3 4 7l4 4" /><path d="M16 3l4 4-4 4" /><path d="M4 7h8a4 4 0 0 1 4 4v10" /><path d="M12 21h8" /></svg>',
      edit: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="m15 3 6 6-9.5 9.5H5.5V12.5Z" /><path d="m13 5 6 6" /><path d="M3 21h6" /></svg>',
      save: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M17 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7Z" /><path d="M17 21v-8H7v8" /><path d="M7 3v5h7" /></svg>',
      cancel: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>',
      kml: '<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9" /><path d="M3 12h18" /><path d="M12 3a15.3 15.3 0 0 0 0 18" /><path d="M12 3a15.3 15.3 0 0 1 0 18" /></svg>',
      shapefile: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 3h7l5 5v11a2 2 0 0 1-2 2H7Z" /><path d="M14 3v5h5" /><path d="M9 12h3" /><path d="M9 16h6" /></svg>',
      patch: '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="4" y="4" width="16" height="16" rx="2" /><path d="M4 10h6v10" /><path d="M14 4v6h6" /></svg>',
      clear: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 6h18" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" /><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><path d="M10 11v6" /><path d="M14 11v6" /></svg>',
      undo: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9 14 4 9l5-5" /><path d="M20 20v-2a6 6 0 0 0-6-6H4" /></svg>',
      redo: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="m15 9 5 5-5 5" /><path d="M4 4v2a6 6 0 0 0 6 6h10" /></svg>'
    };

    // Notificação central
    function notifyCenter(message, type = 'success', ms = 1800){
      try {
        const el = document.createElement('div');
        el.className = 'notify-center ' + (type || '');
        el.textContent = String(message);
        document.body.appendChild(el);
        requestAnimationFrame(() => el.classList.add('show'));
        setTimeout(() => { el.classList.remove('show'); setTimeout(() => { try { el.remove(); } catch {} }, 220); }, ms);
      } catch {}
    }
    // ConfirmaÇõÇœo inline para evitar o alerta do navegador
    function inlineConfirm(message, title = 'Confirmacao'){
      return new Promise(resolve => {
        const overlay = document.createElement('div'); overlay.className = 'confirm-overlay';
        const card = document.createElement('div'); card.className = 'confirm-card';
        const h3 = document.createElement('h3'); h3.textContent = title;
        const p = document.createElement('p'); p.textContent = message;
        const actions = document.createElement('div'); actions.className = 'confirm-actions';
        const btnCancel = document.createElement('button'); btnCancel.className = 'btn ghost'; btnCancel.textContent = 'Cancelar';
        const btnOk = document.createElement('button'); btnOk.className = 'btn primary'; btnOk.textContent = 'OK';
        actions.appendChild(btnCancel); actions.appendChild(btnOk);
        card.appendChild(h3); card.appendChild(p); card.appendChild(actions);
        overlay.appendChild(card); document.body.appendChild(overlay);
        const cleanup = () => { try { overlay.remove(); } catch {} document.removeEventListener('keydown', onKey); };
        const resolveFalse = () => { cleanup(); resolve(false); };
        const resolveTrue = () => { cleanup(); resolve(true); };
        const onKey = e => { if(e.key === 'Escape'){ resolveFalse(); } if(e.key === 'Enter'){ resolveTrue(); } };
        btnCancel.addEventListener('click', resolveFalse);
        btnOk.addEventListener('click', resolveTrue);
        overlay.addEventListener('click', e => { if(e.target === overlay) resolveFalse(); });
        document.addEventListener('keydown', onKey);
        btnOk.focus();
      });
    }

    function initMap(){
      map = L.map('map', { zoomControl: true });
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap', maxZoom: 19 });
      const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri, Maxar', maxZoom: 19 });
      const esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', { attribution: '&copy; Esri', opacity: .8, maxZoom: 19 });
      let esriFailed = 0; esriSat.on('tileerror', () => { esriFailed++; if(esriFailed>=3){ if(map.hasLayer(esriSat)) map.removeLayer(esriSat); osm.addTo(map); } });
      esriSat.addTo(map); esriLabels.addTo(map);
      L.control.layers({ 'Satélite (Esri)': esriSat, 'Rua (OSM)': osm }, { 'Rótulos (Esri)': esriLabels }, { collapsed: true, position: 'topleft' }).addTo(map);
      map.setView([-15.78,-47.93], 4);
      map.whenReady(() => { try { map.invalidateSize(true); } catch {} }); setTimeout(() => { try { map.invalidateSize(true); } catch {} }, 300);

      if(map.pm){
        map.pm.addControls({ position:'topleft', drawMarker:false, drawPolyline:false, drawRectangle:false, drawCircle:false, drawCircleMarker:false, drawPolygon:false, editMode:true, dragMode:false, cutPolygon:true, removalMode:true });
      }
      addFillHoleControl();
    }

    function addFeatureToMap(feature, name, fileName){
      const id = nextId++;
      const color = basePalette[(id-1)%basePalette.length];
      const layer = L.geoJSON(feature, { style: () => ({ ...baseStyle, color, fillColor: color }) }).addTo(map);
      layer.eachLayer(l => { l.on('click', () => toggleSelect(id)); l.options.pmIgnore = true; });
      const item = { id, layer, feature, name, fileName, color };
      allItems.set(id, item);
      appendListItem(item);
    }

    function appendListItem(item){
      const list = document.getElementById('list');
      const el = document.createElement('div'); el.className = 'item'; el.id = 'item-'+item.id;
      el.innerHTML = `<div style="display:flex;gap:.5rem;align-items:center;">
          <input type="checkbox" id="chk-${item.id}" />
          <div>
            <div class="name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</div>
            <div class="muted" style="font-size:.75rem;opacity:.8;">${escapeHtml(item.fileName)}</div>
          </div>
        </div>
        <span class="pill">ID ${item.id}</span>`;
      list.appendChild(el);
      document.getElementById('chk-'+item.id).addEventListener('change', e => { if(e.target.checked) select(item.id); else deselect(item.id); });
    }

    function select(id){ if(!allItems.has(id) || selectedIds.has(id)) return; selectedIds.add(id); const {layer}=allItems.get(id); layer.setStyle({...selectedStyle}); const chk=document.getElementById('chk-'+id); if(chk && !chk.checked) chk.checked = true; updateSelectedCount(); }
    function deselect(id){ if(!allItems.has(id) || !selectedIds.has(id)) return; selectedIds.delete(id); const it=allItems.get(id); if(it&&it.layer){ const color=it.color||baseStyle.color; it.layer.setStyle({ ...baseStyle, color, fillColor: color }); } const chk=document.getElementById('chk-'+id); if(chk && chk.checked) chk.checked = false; updateSelectedCount(); }
    function toggleSelect(id){ selectedIds.has(id) ? deselect(id) : select(id); }

    function setResultLayerStyle(idx, selected){
      const lyr = resultLayers[idx]; const color = resultColors[idx] || '#c62828';
      if(!lyr) return;
      const style = selected ? { color:'#22c55e', weight:4, fillColor:'#22c55e', fillOpacity:0.28 } : { color, weight:3, fillColor:color, fillOpacity:.25 };
      try { lyr.setStyle ? lyr.setStyle(style) : null; lyr.eachLayer && lyr.eachLayer(l=>l.setStyle && l.setStyle(style)); } catch {}
    }
    function selectResult(idx){ if(idx<0 || idx>=resultLayers.length || selectedResultIds.has(idx)) return; selectedResultIds.add(idx); setResultLayerStyle(idx,true); updateSelectedCount(); }
    function deselectResult(idx){ if(!selectedResultIds.has(idx)) return; selectedResultIds.delete(idx); setResultLayerStyle(idx,false); updateSelectedCount(); }
    function toggleResult(idx){ selectedResultIds.has(idx) ? deselectResult(idx) : selectResult(idx); }

    function computeSelectedAreaHa(){
      try {
        let totalM2=0;
        for(const id of selectedIds){
          const it=allItems.get(id); if(!it||!it.feature) continue;
          const a=turf.area(it.feature); if(Number.isFinite(a)) totalM2+=a;
        }
        for(const idx of selectedResultIds){
          const f=resultFeatures[idx]; if(!f) continue;
          const a=turf.area(f); if(Number.isFinite(a)) totalM2+=a;
        }
        return Math.round((totalM2/10000)*100)/100;
      } catch { return 0; }
    }
    function computeTotalAreaHa(){
      try{
        let totalM2=0;
        for(const it of allItems.values()){
          if(!it||!it.feature) continue;
          const a=turf.area(it.feature); if(Number.isFinite(a)) totalM2+=a;
        }
        for(const f of resultFeatures){
          if(!f) continue;
          const a=turf.area(f); if(Number.isFinite(a)) totalM2+=a;
        }
        return Math.round((totalM2/10000)*100)/100;
      }catch{return 0;}
    }
    function updateSelectedCount(){
      const n = selectedIds.size + selectedResultIds.size;
      const ha = computeSelectedAreaHa();
      const elN=document.getElementById('countSelected'); const elHa=document.getElementById('haSelected');
      if(elN) elN.textContent=String(n);
      if(elHa) elHa.textContent=ha.toFixed(2);
      const totalHa=document.getElementById('totalHa');
      if(totalHa) totalHa.textContent = computeTotalAreaHa().toFixed(2);
    }

    function clearAll(){ stopFillMode(); for(const {layer} of allItems.values()){ try{ map.removeLayer(layer);}catch{} } allItems.clear(); selectedIds.clear(); selectedResultIds.clear(); updateSelectedCount(); document.getElementById('list').innerHTML=''; for(const l of resultLayers){ try{ map.removeLayer(l);}catch{} } for(const lbl of resultLabels){ try{ map.removeLayer(lbl);}catch{} } resultLayers.length=0; resultFeatures.length=0; resultColors.length=0; resultLabels.length=0; lastResult=null; updateSelectedCount(); }

    function fitAllBounds(){ const group = L.featureGroup([...Array.from(allItems.values()).map(it=>it.layer)]); if(group.getLayers().length){ map.fitBounds(group.getBounds().pad(0.15)); } }

    async function readKmlText(file){ try { return await file.text(); } catch {} try { const ab=await file.arrayBuffer(); return new TextDecoder('utf-8').decode(ab); } catch {} try { const ab=await file.arrayBuffer(); return new TextDecoder('windows-1252').decode(ab); } catch {} return ''; }
    function extractPolygonFeaturesFromFeature(src){ const props=(src&&src.properties)||{}; const name=props.name||props.NOME||props.Nome; const g=src&&src.geometry; const makeF=geom=>({ type:'Feature', properties:{ ...props, name }, geometry: geom }); if(!g) return []; if(g.type==='Polygon'||g.type==='MultiPolygon') return [makeF(g)]; if(g.type==='GeometryCollection'&&Array.isArray(g.geometries)){ const out=[]; g.geometries.forEach(gg=>{ if(gg&&(gg.type==='Polygon'||gg.type==='MultiPolygon')) out.push(makeF(gg)); }); return out; } return []; }

    async function handleFiles(files){
      const fileArr = Array.from(files || []);
      if(fileArr.length){ const nm = fileArr[0].name || ''; const idx = nm.lastIndexOf('.'); lastInputBaseName = (idx>0 ? nm.slice(0,idx) : nm) || 'talhoes'; }
      for(const file of fileArr){ if(!file.name.toLowerCase().endsWith('.kml')) continue; const text = await readKmlText(file); if(!text.trim()) continue; const xml = new DOMParser().parseFromString(text, 'text/xml'); if(!toGeoJSON || !toGeoJSON.kml){ alert('toGeoJSON indisponível.'); return; } const gj = toGeoJSON.kml(xml); if(!gj || !gj.features) continue; let count=0; gj.features.forEach((f,idx)=>{ const list = extractPolygonFeaturesFromFeature(f); list.forEach((pf,k)=>{ const nm = pf.properties && pf.properties.name ? pf.properties.name : `${file.name} #${idx+1}${list.length>1?'-'+(k+1):''}`; addFeatureToMap(pf,nm,file.name); count++; }); }); console.log(`Carregado: ${file.name} (${count} polígonos)`); }
      fitAllBounds();
      updateSelectedCount();
    }

    function safeClean(feature){ try { const cleaned = turf.buffer(feature, 0, { units:'meters' }); if(cleaned && cleaned.geometry) return cleaned; } catch {} return feature; }
    function safeUnion(a,b){ try { const u=turf.union(a,b); if(u) return u; } catch {} try { const fc={ type:'FeatureCollection', features:[a,b] }; const c=turf.combine(fc); if(c&&c.features&&c.features[0]) return c.features[0]; } catch {} return a; }
    function toSingleFeature(geo){ if(!geo) return null; if(geo.type==='Feature') return geo; if(geo.type==='FeatureCollection'){ if(!geo.features||!geo.features.length) return null; let acc=geo.features[0]; for(let i=1;i<geo.features.length;i++) acc=safeUnion(acc,geo.features[i]); return acc; } return { type:'Feature', properties:{}, geometry: geo.geometry||geo } }
    function makeAreaLabel(feature, text){
      try{
        const center = (turf.centroid(feature).geometry && turf.centroid(feature).geometry.coordinates) || null;
        const coords = center ? [center[1],center[0]] : null;
        if(!coords) return null;
        const html = `<div class="area-badge"><span class="area-num">${escapeHtml(text)}</span><span class="area-unit">ha</span></div>`;
        return L.marker(coords,{ interactive:false, icon:L.divIcon({ className:'area-label', html })});
      }catch{return null;}
    }
    function addResultLabel(idx, feature){
      const ha = computeAreaHa(feature);
      const text = ha!==null ? `${ha.toFixed(2)}` : '';
      const lbl = makeAreaLabel(feature,text);
      if(lbl){ lbl.addTo(map); resultLabels[idx]=lbl; }
    }
    function removeResultLabel(idx){ const lbl=resultLabels[idx]; if(lbl){ try{ map.removeLayer(lbl);}catch{} } resultLabels[idx]=undefined; }

    function getSelectedFeatures(){
      const feats=[];
      for(const id of selectedIds){ const it=allItems.get(id); if(it) feats.push(it.feature); }
      for(const idx of selectedResultIds){ const f=resultFeatures[idx]; if(f) feats.push(f); }
      return feats;
    }

    function captureState(){
      const deep = obj => JSON.parse(JSON.stringify(obj));
      return {
        nextId,
        lastInputBaseName,
        items: Array.from(allItems.values()).map(it => ({
          id: it.id,
          name: it.name,
          fileName: it.fileName,
          color: it.color,
          feature: deep(it.feature)
        })),
        results: resultFeatures.map((f,i)=>({ feature: deep(f), color: resultColors[i] || null })),
        selectedIds: Array.from(selectedIds),
        selectedResultIds: Array.from(selectedResultIds)
      };
    }
    function restoreState(snapshot){
      if(!snapshot) return;
      clearAll();
      nextId = 1;
      lastInputBaseName = snapshot.lastInputBaseName || 'talhoes';
      for(const it of snapshot.items || []){
        const id = it.id || nextId++;
        const color = it.color || basePalette[(id-1)%basePalette.length];
        const layer=L.geoJSON(it.feature,{ style:()=>({ ...baseStyle, color, fillColor: color }) }).addTo(map);
        layer.eachLayer(l=>{ l.on('click',()=>toggleSelect(id)); l.options.pmIgnore=true; });
        allItems.set(id,{ id, layer, feature: it.feature, name: it.name, fileName: it.fileName, color });
        nextId = Math.max(nextId, id+1);
      }
      for(let i=0;i<(snapshot.results||[]).length;i++){
        const r = snapshot.results[i];
        if(!r || !r.feature) continue;
        const color = r.color || '#c62828';
        const layer=L.geoJSON(r.feature,{ style:()=>({ color, weight:3, fillColor: color, fillOpacity:.25 }) }).addTo(map);
        layer.eachLayer && layer.eachLayer(l=>{ l.on('click',()=>toggleResult(i)); });
        resultFeatures.push(r.feature);
        resultLayers.push(layer);
        resultColors.push(color);
        addResultLabel(i, r.feature);
      }
      selectedIds.clear(); (snapshot.selectedIds||[]).forEach(id=>select(id));
      selectedResultIds.clear(); (snapshot.selectedResultIds||[]).forEach(idx=>selectResult(idx));
      lastResult = { type:'FeatureCollection', features:[...resultFeatures] };
      updateSelectedCount();
    }
    function pushUndo(){
      undoStack.push(captureState());
      if(undoStack.length>30) undoStack.shift();
      redoStack.length = 0;
      updateUndoButtons();
    }
    function undo(){
      if(!undoStack.length) return;
      const snap = undoStack.pop();
      redoStack.push(captureState());
      restoreState(snap);
      updateUndoButtons();
      notifyCenter('Desfeito','success',1000);
    }
    function redo(){
      if(!redoStack.length) return;
      const snap = redoStack.pop();
      undoStack.push(captureState());
      restoreState(snap);
      updateUndoButtons();
      notifyCenter('Refeito','success',1000);
    }
    function updateUndoButtons(){
      const undoBtn = document.getElementById('btnUndoFloating');
      const redoBtn = document.getElementById('btnRedoFloating');
      if(undoBtn) undoBtn.disabled = undoStack.length===0;
      if(redoBtn) redoBtn.disabled = redoStack.length===0;
    }

    function mergeSelected(){
      const feats = getSelectedFeatures(); if(!feats.length){ alert('Selecione ao menos um talhão.'); return; }
      const tolM = Number(document.getElementById('tol').value||0);
      try {
        pushUndo();
        const cleaned = feats.map(safeClean);
        let merged = null;
        if(tolM>0){ const buffered = cleaned.map(f => turf.buffer(f,tolM,{units:'meters'})); merged = buffered.reduce((acc,cur)=>acc?safeUnion(acc,cur):cur,null); try{ const shr = turf.buffer(merged,-tolM,{units:'meters'}); if(shr&&shr.geometry) merged = shr; } catch{} } else { merged = cleaned.reduce((acc,cur)=>acc?safeUnion(acc,cur):cur,null); }
        if(!merged){ alert('Falha ao mesclar.'); return; }
        const one = toSingleFeature(merged); if(!one){ alert('Falha ao normalizar.'); return; }
        // remove originais selecionados
        for(const id of Array.from(selectedIds)){ const it = allItems.get(id); if(it){ try{ map.removeLayer(it.layer);}catch{} const row=document.getElementById('item-'+id); if(row&&row.parentNode) row.parentNode.removeChild(row); allItems.delete(id); } }
        selectedIds.clear(); updateSelectedCount();
        // remover resultados selecionados (para não duplicar)
        const toRemove = Array.from(selectedResultIds).sort((a,b)=>b-a);
        for(const idx of toRemove){
          const lyr=resultLayers[idx]; try{ map.removeLayer(lyr);}catch{}
          removeResultLabel(idx);
          resultLayers.splice(idx,1); resultFeatures.splice(idx,1); resultColors.splice(idx,1); resultLabels.splice(idx,1);
        }
        selectedIds.clear(); selectedResultIds.clear(); updateSelectedCount();
        // adicionar resultado com cor distinta
        resultFeatures.push(one);
        const palette=['#ef4444','#22c55e','#3b82f6','#f59e0b','#a855f7','#14b8a6','#e11d48','#10b981','#6366f1','#84cc16'];
        const color = palette[(resultFeatures.length-1)%palette.length]; resultColors.push(color);
        const idxNew = resultFeatures.length-1;
        const rLayer = L.geoJSON(one, { style: ()=>({ color, weight:3, fillColor:color, fillOpacity:.25 }) }).addTo(map);
        rLayer.eachLayer && rLayer.eachLayer(l=>{ l.on('click',()=>toggleResult(idxNew)); });
        resultLayers.push(rLayer);
        addResultLabel(idxNew, one);
        try{ map.fitBounds(rLayer.getBounds().pad(0.15)); }catch{}
        lastResult = { type:'FeatureCollection', features:[...resultFeatures] };
        notifyCenter('Mescla concluída','success',1600);
      } catch(e){ console.error(e); alert('Erro durante a mescla.'); }
    }

    function computeAreaHa(feature){ try{ const a=turf.area(feature); if(Number.isFinite(a)) return Number((a/10000).toFixed(4)); }catch{} return null; }
    function sanitizeForKml(fc){ try{ const out={ type:'FeatureCollection', features:[] }; (fc.features||[]).forEach((f,i)=>{ if(!f||!f.geometry) return; const src=f.properties||{}; const props={}; for(const k in src){ if(!Object.prototype.hasOwnProperty.call(src,k)) continue; const v=src[k]; if(v===undefined||v===null) props[k]=''; else if(typeof v==='object'){ try{ props[k]=JSON.stringify(v);}catch{ props[k]=String(v);} } else props[k]=String(v); } if(props.name===undefined) props.name='resultado_'+(i+1); const ha = computeAreaHa(f); if(ha!==null) props.ha = ha; out.features.push({ type:'Feature', properties:props, geometry:f.geometry }); }); return out; } catch { return fc; } }

    async function ensureToKml(){ if(typeof window.tokml!=='undefined') return true; try{ await loadScriptOnce('https://cdn.jsdelivr.net/npm/tokml@0.4.0/tokml.js'); }catch{} return typeof window.tokml!=='undefined'; }
    function basicGeoJsonToKml(fc){ if(!fc||!fc.features) return ''; const header='<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document>'; const footer='</Document></kml>'; function ringToStr(r){ return r.map(([x,y])=>`${x},${y},0`).join(' ');} const placemarks = fc.features.map((f,i)=>{ if(!f||!f.geometry) return ''; const nm=(f.properties&&(f.properties.name||f.properties.NOME||f.properties.Nome))||`feature_${i+1}`; const g=f.geometry; if(g.type==='Polygon'){ const rings=g.coordinates||[]; if(!rings.length) return ''; const outer=`<outerBoundaryIs><LinearRing><coordinates>${ringToStr(rings[0])}</coordinates></LinearRing></outerBoundaryIs>`; const inners=rings.slice(1).map(r=>`<innerBoundaryIs><LinearRing><coordinates>${ringToStr(r)}</coordinates></LinearRing></innerBoundaryIs>`).join(''); return `<Placemark><name>${nm}</name><Polygon><tessellate>1</tessellate>${outer}${inners}</Polygon></Placemark>`; } if(g.type==='MultiPolygon'){ const polys=(g.coordinates||[]).map(poly=>{ if(!poly||!poly.length) return ''; const outer=`<outerBoundaryIs><LinearRing><coordinates>${ringToStr(poly[0])}</coordinates></LinearRing></outerBoundaryIs>`; const inners=poly.slice(1).map(r=>`<innerBoundaryIs><LinearRing><coordinates>${ringToStr(r)}</coordinates></LinearRing></innerBoundaryIs>`).join(''); return `<Polygon><tessellate>1</tessellate>${outer}${inners}</Polygon>`; }).join(''); return `<Placemark><name>${nm}</name>${polys}</Placemark>`; } return ''; }).join(''); return header+placemarks+footer; }

    function applyRedStyleToKml(kmlString){
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(kmlString, 'text/xml');
        const kml = doc.getElementsByTagName('kml')[0] || doc.documentElement;
        const documentNode = doc.getElementsByTagName('Document')[0] || (()=>{ const d=doc.createElement('Document'); kml.appendChild(d); return d;})();
        const styleId = 'talhaoStyle';
        let style = doc.getElementById(styleId);
        if(!style){
          style = doc.createElement('Style'); style.setAttribute('id', styleId);
          const line = doc.createElement('LineStyle');
          const lineColor = doc.createElement('color'); lineColor.textContent = 'ff0000ff'; // KML usa AABBGGRR
          const width = doc.createElement('width'); width.textContent = '2.5';
          line.appendChild(lineColor); line.appendChild(width);
          const poly = doc.createElement('PolyStyle');
          const polyColor = doc.createElement('color'); polyColor.textContent = '4d0000ff'; // semi-transparente
          poly.appendChild(polyColor);
          style.appendChild(line); style.appendChild(poly);
          documentNode.insertBefore(style, documentNode.firstChild);
        }
        const placemarks = Array.from(doc.getElementsByTagName('Placemark'));
        placemarks.forEach(pm => {
          let su = pm.getElementsByTagName('styleUrl')[0];
          if(!su){ su = doc.createElement('styleUrl'); pm.insertBefore(su, pm.firstChild); }
          su.textContent = `#${styleId}`;
        });
        return new XMLSerializer().serializeToString(doc);
      } catch { return kmlString; }
    }

    function exportKML(){
      if(!lastResult || !lastResult.features || !lastResult.features.length){ alert('Nada para exportar. Faça uma mescla.'); return; }
      (async ()=>{
        try{
          let kmlString=''; const ok = await ensureToKml(); if(ok){ kmlString = tokml(sanitizeForKml(lastResult), { name:'name' }); } else { kmlString = basicGeoJsonToKml(sanitizeForKml(lastResult)); }
          if(!kmlString) throw new Error('KML vazio');
          const styled = applyRedStyleToKml(kmlString);
          const outName = `${lastInputBaseName || 'talhoes'}_talhoes_mesclados.kml`;
          const blob = new Blob([styled], { type:'application/vnd.google-earth.kml+xml' }); saveAs(blob,outName);
        }catch(e){ console.error(e); alert('Falha ao exportar KML.'); }
      })();
    }

    // Loader dinâmico (reuso)
    const _loadedScripts = new Set();
    function loadScriptOnce(src){ return new Promise((resolve,reject)=>{ if(_loadedScripts.has(src)) return resolve(); const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>{ _loadedScripts.add(src); resolve(); }; s.onerror=reject; document.head.appendChild(s); }); }

    async function ensureShpWrite(){
      if(typeof window.shpwrite !== 'undefined') return true;
      const sources = [
        'lib/shpwrite.min.js',
        'https://unpkg.com/shp-write@0.3.2/shpwrite.js',
        'https://cdn.jsdelivr.net/gh/mapbox/shp-write@0.3.2/shpwrite.js'
      ];
      for(const src of sources){
        try { await loadScriptOnce(src); if(typeof window.shpwrite !== 'undefined') return true; } catch {}
      }
      return typeof window.shpwrite !== 'undefined';
    }
    async function exportSHP(){
      if(!lastResult || !lastResult.features || !lastResult.features.length){ alert('Nada para exportar. Faça uma mescla.'); return; }
      if(typeof JSZip==='undefined'){ alert('Biblioteca JSZip indisponível.'); return; }
      try {
        const ok = await ensureShpWrite(); if(!ok){ alert('Biblioteca shpwrite indisponível.'); return; }
        const rows=[]; const geometries=[]; (lastResult.features||[]).forEach(f=>{ if(!f||!f.geometry) return; const t=f.geometry.type; if(t!=='Polygon'&&t!=='MultiPolygon') return; const props={...(f.properties||{})}; const ha = computeAreaHa(f); if(ha!==null) props.ha = ha; props.stroke='#c62828'; props['stroke-width']=2.5; props.fill='#c62828'; props['fill-opacity']=0.3; rows.push(props); geometries.push(f.geometry.coordinates); }); if(!geometries.length){ alert('Sem polígonos para exportar.'); return; }
        await new Promise((resolve,reject)=>{ shpwrite.write(rows,'POLYGON',geometries,(err,files)=>{ if(err) return reject(err); try{ const zip=new JSZip(); const folder=zip.folder('export'); const base=`${lastInputBaseName || 'talhoes'}_talhoes_mesclados`; folder.file(base+'.shp', files.shp.buffer, {binary:true}); folder.file(base+'.shx', files.shx.buffer, {binary:true}); folder.file(base+'.dbf', files.dbf.buffer, {binary:true}); folder.file(base+'.prj', files.prj); const qml = `<!DOCTYPE qgis PUBLIC 'http://mrcc.com/qgis.dtd' 'SYSTEM'>\n<qgis version=\"3\" styleCategories=\"Symbology\">\n  <renderer-v2 type=\"singleSymbol\">\n    <symbols>\n      <symbol type=\"fill\" alpha=\"1\" name=\"0\">\n        <layer class=\"SimpleFill\" enabled=\"1\">\n          <prop k=\"color\" v=\"198,40,40,76\"/>\n          <prop k=\"outline_color\" v=\"198,40,40,255\"/>\n          <prop k=\"outline_width\" v=\"0.8\"/>\n        </layer>\n      </symbol>\n    </symbols>\n  </renderer-v2>\n</qgis>`; folder.file(base+'.qml', qml); zip.generateAsync({type:'blob',compression:'STORE'}).then(blob=>{ saveAs(blob,base+'.zip'); resolve(); }).catch(reject); }catch(e){ reject(e); } }); });
      } catch(e){ console.error(e); alert('Falha ao exportar Shapefile.'); }
    }

    // Edição
    function setEditableForItem(item, enabled){ try{ item.layer.eachLayer(l=>{ l.options.pmIgnore=!enabled; if(!l.pm) return; if(enabled) l.pm.enable({ allowSelfIntersection:false, snappable:true, snapDistance:20 }); else l.pm.disable(); }); }catch{} }
    function setEditableForResultIndex(idx, enabled){ const lyr=resultLayers[idx]; if(!lyr) return; try{ lyr.eachLayer?lyr.eachLayer(l=>{ if(l.pm){ if(enabled) l.pm.enable(); else l.pm.disable(); } l.options.pmIgnore=!enabled; }):(lyr.pm?(enabled?lyr.pm.enable():lyr.pm.disable()):null); }catch{} }
    function enableEditSelected(){ for(const [id,item] of allItems){ setEditableForItem(item, selectedIds.has(id)); } for(let i=0;i<resultLayers.length;i++){ setEditableForResultIndex(i,true);} editActive=true; notifyCenter('Edição ativada','success',1200); }
    function disableAllEditing(){ for(const [,item] of allItems){ setEditableForItem(item,false);} for(let i=0;i<resultLayers.length;i++){ setEditableForResultIndex(i,false);} editActive=false; }
    function toSingleFeatureFromLayer(layer){ try{ const gj=layer.toGeoJSON(); if(!gj) return null; if(gj.type==='Feature') return gj; if(gj.type==='FeatureCollection'){ if(!gj.features||!gj.features.length) return null; let acc=gj.features[0]; for(let i=1;i<gj.features.length;i++) acc=safeUnion(acc,gj.features[i]); return acc; } return { type:'Feature', properties:{}, geometry:(gj.geometry||gj) }; } catch { return null; } }
    function saveEdits(){  pushUndo(); for(const id of selectedIds){ const it=allItems.get(id); if(!it) continue; const one=toSingleFeatureFromLayer(it.layer); if(one&&one.geometry){ it.feature=one; } setEditableForItem(it,false);} for(let i=0;i<resultLayers.length;i++){ const lyr=resultLayers[i]; const one=toSingleFeatureFromLayer(lyr); if(one&&one.geometry){ resultFeatures[i]=one; removeResultLabel(i); addResultLabel(i,one); } setEditableForResultIndex(i,false);} lastResult={ type:'FeatureCollection', features:[...resultFeatures] }; editActive=false; updateSelectedCount(); notifyCenter('Edições salvas','success',1200); }
    function cancelEdits(){
      for(const id of selectedIds){
        const it=allItems.get(id); if(!it) continue;
        try{ map.removeLayer(it.layer);}catch{}
        const color = it.color || baseStyle.color;
        const layer=L.geoJSON(it.feature,{ style:()=>({ ...baseStyle, color, fillColor: color }) }).addTo(map);
        layer.eachLayer(l=>{ l.on('click',()=>toggleSelect(id)); l.options.pmIgnore=true; });
        it.layer=layer;
      }
      for(let i=0;i<resultLayers.length;i++){
        const feat=resultFeatures[i]; const old=resultLayers[i];
        try{ map.removeLayer(old);}catch{}
        removeResultLabel(i);
        const layer=L.geoJSON(feat,{ style:()=>({ color: resultColors[i]||'#f97316', weight:3, fillColor: resultColors[i]||'#f97316', fillOpacity:.25 }) }).addTo(map);
        layer.eachLayer && layer.eachLayer(l=>{ l.on('click',()=>toggleResult(i)); });
        addResultLabel(i, feat);
        if(selectedResultIds.has(i)) setResultLayerStyle(i,true);
        resultLayers[i]=layer;
      }
      disableAllEditing(); stopFillMode(); notifyCenter('Edições canceladas','success',1200);
    }

    // Preencher buracos desenhando um patch e unindo ao polígono alvo
    function stopFillMode(){ if(!fillMode) return; fillMode=false; if(fillControlBtn) fillControlBtn.classList.remove('active'); try{ map.pm.disableDraw('Polygon'); }catch{} }
    function startFillMode(){
      if(!map.pm){ alert('Ferramenta de desenho indisponível.'); return; }
      stopFillMode();
      fillMode = true;
      if(fillControlBtn) fillControlBtn.classList.add('active');
      try { map.pm.enableDraw('Polygon', { snappable:true, snapDistance:20, templineStyle:{color:'#c62828'}, hintlineStyle:{color:'#c62828',dashArray:[5,5]} }); } catch {}
      notifyCenter('Desenhe o polígono que deseja preencher e finalize o desenho.','success',1800);
    }
    function applyPatchToLayer(layer, color, style){
      pushUndo();
      const patch = toSingleFeatureFromLayer(layer); try{ map.removeLayer(layer);}catch{}
      if(!patch||!patch.geometry){ notifyCenter('Falha ao capturar o desenho.','error',1500); return false; }
      let target=null; let targetId=null; let targetType='result'; // result|item
      // Prioriza itens selecionados
      for(const id of selectedIds){ const it=allItems.get(id); if(!it||!it.feature) continue; try{ if(turf.booleanIntersects(it.feature, patch)){ target=it; targetId=id; targetType='item'; break; } }catch{} if(!target){ target=it; targetId=id; targetType='item'; break; }
      }
      // Senão, tenta resultados
      if(!target && resultFeatures.length){
        for(let i=0;i<resultFeatures.length;i++){
          const f=resultFeatures[i]; if(!f||!f.geometry) continue;
          try{ if(turf.booleanIntersects(f,patch)){ target=i; targetType='result'; break; } }catch{}
        }
        if(target===null) target = resultFeatures.length-1 >=0 ? resultFeatures.length-1 : null;
      }
      if(target===null){ notifyCenter('Nenhum polígono para aplicar o preenchimento. Selecione um alvo.','error',1800); return false; }
      if(targetType==='item'){
        const it = target;
        const merged = safeUnion(safeClean(it.feature), safeClean(patch));
        if(!merged||!merged.geometry){ notifyCenter('Não foi possível unir ao talhão.','error',1600); return false; }
        it.feature = merged;
        try{ map.removeLayer(it.layer);}catch{}
        const newLayer=L.geoJSON(merged,{ style:()=>({...selectedStyle}) }).addTo(map);
        newLayer.eachLayer(l=>{ l.on('click',()=>toggleSelect(it.id)); l.options.pmIgnore=true; });
        it.layer=newLayer;
      } else {
        const idx = typeof target==='number'?target:0;
        const merged = safeUnion(safeClean(resultFeatures[idx]), safeClean(patch));
        if(!merged||!merged.geometry){ notifyCenter('Não foi possível unir ao resultado.','error',1600); return false; }
        resultFeatures[idx]=merged;
        const oldLayer=resultLayers[idx];
        try{ map.removeLayer(oldLayer);}catch{}
        removeResultLabel(idx);
        const newLayer=L.geoJSON(merged,{ style:()=>({ color: resultColors[idx]||color||'#c62828', weight:3, fillColor: resultColors[idx]||color||'#c62828', fillOpacity:.25 }) }).addTo(map);
        resultLayers[idx]=newLayer;
        addResultLabel(idx, merged);
        try{ map.fitBounds(newLayer.getBounds().pad(0.05)); }catch{}
      }
      lastResult={ type:'FeatureCollection', features:[...resultFeatures] };
      updateSelectedCount();
      notifyCenter('Preenchimento aplicado','success',1400);
      return true;
    }
    function onPmCreate(e){
      if(!fillMode) return;
      stopFillMode();
      applyPatchToLayer(e.layer, '#c62828', selectedStyle);
    }

    function applyButtonIcons(){
      const mapIcons = [
        ['btnClear','clear','Limpar tudo'],
        ['btnMerge','merge','Mesclar selecionados'],
        ['btnEdit','edit','Editar'],
        ['btnSaveEdits','save','Salvar edições'],
        ['btnCancelEdits','cancel','Cancelar edições'],
        ['btnExportKML','kml','Exportar KML'],
        ['btnExportSHP','shapefile','Exportar Shapefile']
      ];
      mapIcons.forEach(([id,name,label])=>{
        const el=document.getElementById(id);
        if(!el) return;
        el.innerHTML = ICONS[name] || '';
        if(!el.classList.contains('icon-btn')) el.classList.add('icon-btn');
        if(label){
          el.title = label;
          el.setAttribute('aria-label', label);
        }
      });
    }

    function addFillHoleControl(){
      if(!map || !L || !L.control) return;
      const ctrl = L.control({ position:'topleft' });
      ctrl.onAdd = function(){
        const container = L.DomUtil.create('div','leaflet-bar');
        const btn = L.DomUtil.create('a','leaflet-bar-part leaflet-bar-part-single icon-btn', container);
        btn.href = '#';
        btn.title = 'Preencher buraco';
        btn.setAttribute('aria-label','Preencher buraco');
        btn.innerHTML = ICONS.patch;
        L.DomEvent.on(btn,'click', L.DomEvent.stop)
          .on(btn,'mousedown', L.DomEvent.stopPropagation)
          .on(btn,'dblclick', L.DomEvent.stopPropagation)
          .on(btn,'click', () => startFillMode());
        fillControlBtn = btn;
        return container;
      };
      ctrl.addTo(map);
    }

    function addFloatingMergeButton(){
      const mapEl = document.getElementById('map');
      if(!mapEl) return;
      let wrap = document.getElementById('floatingMergeWrap');
      if(wrap) return;
      wrap = document.createElement('div');
      wrap.id = 'floatingMergeWrap';
      wrap.className = 'floating-merge';
      const btnUndo = document.createElement('button');
      btnUndo.id = 'btnUndoFloating';
      btnUndo.className = 'btn ghost icon-btn';
      btnUndo.title = 'Desfazer';
      btnUndo.setAttribute('aria-label','Desfazer');
      btnUndo.innerHTML = ICONS.undo || 'Undo';
      btnUndo.addEventListener('click', undo);
      wrap.appendChild(btnUndo);

      const btnRedo = document.createElement('button');
      btnRedo.id = 'btnRedoFloating';
      btnRedo.className = 'btn ghost icon-btn';
      btnRedo.title = 'Refazer';
      btnRedo.setAttribute('aria-label','Refazer');
      btnRedo.innerHTML = ICONS.redo || 'Redo';
      btnRedo.addEventListener('click', redo);
      wrap.appendChild(btnRedo);

      const btn = document.createElement('button');
      btn.id = 'btnMergeFloating';
      btn.className = 'btn primary';
      btn.title = 'Mesclar selecionados';
      btn.setAttribute('aria-label','Mesclar selecionados');
      btn.innerHTML = `${ICONS.merge || ''}<span>Mesclar</span>`;
      btn.addEventListener('click', mergeSelected);
      wrap.appendChild(btn);
      mapEl.appendChild(wrap);
      updateUndoButtons();
    }

    function escapeHtml(str){ return String(str).replace(/[&<>"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s])); }

    window.addEventListener('DOMContentLoaded', () => {
      initMap();
      if(map && map.on){ map.on('pm:create', onPmCreate); }
      applyButtonIcons();
      addFloatingMergeButton();
      updateUndoButtons();
      document.getElementById('fileInput').addEventListener('change', e => handleFiles(e.target.files));
      document.getElementById('btnClear').addEventListener('click', async () => {
        const ok = await inlineConfirm('Remover todas as camadas e sele??es?','Limpar mapa');
        if(ok){ pushUndo(); clearAll(); updateUndoButtons(); }
      });
      document.getElementById('btnMerge').addEventListener('click', mergeSelected);
      document.getElementById('btnEdit').addEventListener('click', () => { if(!editActive) enableEditSelected(); else disableAllEditing(); });
      document.getElementById('btnSaveEdits').addEventListener('click', saveEdits);
      document.getElementById('btnCancelEdits').addEventListener('click', cancelEdits);
      document.getElementById('btnExportKML').addEventListener('click', exportKML);
      document.getElementById('btnExportSHP').addEventListener('click', exportSHP);
      document.getElementById('btnSelectAll').addEventListener('click', () => { for(const id of allItems.keys()) select(id); for(let i=0;i<resultLayers.length;i++) selectResult(i); });
      document.getElementById('btnSelectNone').addEventListener('click', () => { for(const id of Array.from(selectedIds)) deselect(id); for(const idx of Array.from(selectedResultIds)) deselectResult(idx); });
    });
  </script>
</body>
</html>
